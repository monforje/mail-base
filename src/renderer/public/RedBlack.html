<!DOCTYPE html>
<html>
  <head>
    <title>Red/Black Tree Visualization</title>
    <meta charset="UTF-8">

    <!-- Прямые пути к файлам в src/renderer -->
    <script src="ThirdParty/jquery-1.5.2.min.js"></script>
    <script src="ThirdParty/jquery-ui-1.8.11.custom.min.js"></script>

    <!-- Javascript для анимации -->
    <script type="text/javascript" src="AnimationLibrary/CustomEvents.js"></script>
    <script type="text/javascript" src="AnimationLibrary/UndoFunctions.js"></script>
    <script type="text/javascript" src="AnimationLibrary/AnimatedObject.js"></script>
    <script type="text/javascript" src="AnimationLibrary/AnimatedLabel.js"></script>
    <script type="text/javascript" src="AnimationLibrary/AnimatedCircle.js"></script>
    <script type="text/javascript" src="AnimationLibrary/AnimatedRectangle.js"></script>
    <script type="text/javascript" src="AnimationLibrary/AnimatedLinkedList.js"></script>
    <script type="text/javascript" src="AnimationLibrary/HighlightCircle.js"></script>
    <script type="text/javascript" src="AnimationLibrary/Line.js"></script>
    <script type="text/javascript" src="AnimationLibrary/ObjectManager.js"></script>
    <script type="text/javascript" src="AnimationLibrary/AnimationMain.js"></script>

    <script type="text/javascript" src="AlgorithmLibrary/Algorithm.js"></script>
    <script type="text/javascript" src="AlgorithmLibrary/RedBlack.js"></script>

    <style>
      body { 
        font-family: Arial, sans-serif; 
        margin: 0; 
        padding: 0;
        background-color: #f5f5f5;
        height: 100vh;
        overflow: hidden;
      }
      #container { 
        width: 100vw;
        height: 100vh;
        margin: 0;
        background: white;
        padding: 0;
        display: flex;
        flex-direction: column;
      }
      #header { 
        background-color: #2c3e50;
        color: white;
        padding: 10px 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        flex-shrink: 0;
      }
      #header h1 { 
        margin: 0;
        font-size: 24px;
        font-weight: normal;
      }
      #mainContent {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }
      #algoControlSection {
        background-color: #ecf0f1;
        padding: 10px 20px;
        border-bottom: 1px solid #bdc3c7;
        flex-shrink: 0;
      }
      #canvas-container {
        flex: 1;
        overflow: hidden;
        position: relative;
        background-color: white;
        margin: 0;
        width: 100%;
        height: 100%;
      }
      #generalAnimationControlSection {
        background-color: #ecf0f1;
        padding: 10px 20px;
        border-top: 1px solid #bdc3c7;
        flex-shrink: 0;
      }
      #footer {
        background-color: #34495e;
        color: #ecf0f1;
        padding: 8px 20px;
        font-size: 12px;
        flex-shrink: 0;
      }
      table { 
        margin: 0;
      }
      button, input { 
        margin: 0 5px; 
        padding: 6px 12px; 
        border: 1px solid #bdc3c7;
        border-radius: 3px;
        font-size: 12px;
      }
      button {
        background-color: #3498db;
        color: white;
        cursor: pointer;
      }
      button:hover {
        background-color: #2980b9;
      }
      .control-buttons {
        text-align: center;
        padding: 10px 20px;
        background-color: #ecf0f1;
        border-top: 1px solid #bdc3c7;
        flex-shrink: 0;
      }
      .instructions {
        text-align: center;
        padding: 5px 20px;
        font-size: 11px;
        color: #7f8c8d;
        background-color: #f8f9fa;
        border-top: 1px solid #dee2e6;
        flex-shrink: 0;
      }
    </style>

    <script>
      // Глобальные переменные для данных
      window.packagesToLoad = [];
      window.treeInitialized = false;
      
      // Переменные для высокого DPI и перемещения
      window.canvasScale = 1;
      window.canvasOffset = { x: 0, y: 0 };
      window.isDragging = false;
      window.lastMousePos = { x: 0, y: 0 };

      // Функция для настройки высокого DPI
      function setupHighDPICanvas(canvas) {
        const ctx = canvas.getContext('2d');
        const devicePixelRatio = window.devicePixelRatio || 1;
        const backingStoreRatio = ctx.webkitBackingStorePixelRatio ||
                                 ctx.mozBackingStorePixelRatio ||
                                 ctx.msBackingStorePixelRatio ||
                                 ctx.oBackingStorePixelRatio ||
                                 ctx.backingStorePixelRatio || 1;

        const ratio = devicePixelRatio / backingStoreRatio;
        
        if (devicePixelRatio !== backingStoreRatio) {
          const oldWidth = canvas.width;
          const oldHeight = canvas.height;

          canvas.width = oldWidth * ratio;
          canvas.height = oldHeight * ratio;

          canvas.style.width = oldWidth + 'px';
          canvas.style.height = oldHeight + 'px';

          ctx.scale(ratio, ratio);
        }
        
        // Улучшенное сглаживание
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        
        window.canvasScale = ratio;
        console.log(`Canvas DPI настроен: ratio = ${ratio}`);
        
        return ctx;
      }

      // Функция для настройки перемещения канваса
      function setupCanvasPanning(canvas) {
        let isDragging = false;
        let lastX = 0;
        let lastY = 0;
        let translateX = 0;
        let translateY = 0;
        let scale = 1;

        // Обработчики мыши
        canvas.addEventListener('mousedown', function(e) {
          isDragging = true;
          lastX = e.clientX;
          lastY = e.clientY;
          canvas.style.cursor = 'grabbing';
          e.preventDefault();
        });

        canvas.addEventListener('mousemove', function(e) {
          if (!isDragging) return;

          const deltaX = e.clientX - lastX;
          const deltaY = e.clientY - lastY;

          translateX += deltaX;
          translateY += deltaY;

          // Применяем трансформацию
          updateCanvasTransform();

          lastX = e.clientX;
          lastY = e.clientY;
          e.preventDefault();
        });

        canvas.addEventListener('mouseup', function(e) {
          isDragging = false;
          canvas.style.cursor = 'grab';
        });

        canvas.addEventListener('mouseleave', function(e) {
          isDragging = false;
          canvas.style.cursor = 'grab';
        });

        // Масштабирование колесиком мыши
        canvas.addEventListener('wheel', function(e) {
          e.preventDefault();
          
          const rect = canvas.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;
          
          const wheel = e.deltaY < 0 ? 1.1 : 0.9;
          const newScale = scale * wheel;
          
          // Ограничиваем масштаб
          if (newScale >= 0.5 && newScale <= 3) {
            // Масштабируем относительно позиции мыши
            translateX = mouseX - (mouseX - translateX) * wheel;
            translateY = mouseY - (mouseY - translateY) * wheel;
            scale = newScale;
            
            updateCanvasTransform();
          }
        });

        // Функция обновления трансформации
        function updateCanvasTransform() {
          canvas.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
        }

        // Обработчики touch для мобильных устройств
        canvas.addEventListener('touchstart', function(e) {
          if (e.touches.length === 1) {
            isDragging = true;
            const touch = e.touches[0];
            lastX = touch.clientX;
            lastY = touch.clientY;
            e.preventDefault();
          }
        });

        canvas.addEventListener('touchmove', function(e) {
          if (!isDragging || e.touches.length !== 1) return;

          const touch = e.touches[0];
          const deltaX = touch.clientX - lastX;
          const deltaY = touch.clientY - lastY;

          translateX += deltaX;
          translateY += deltaY;

          updateCanvasTransform();

          lastX = touch.clientX;
          lastY = touch.clientY;
          e.preventDefault();
        });

        canvas.addEventListener('touchend', function(e) {
          isDragging = false;
        });

        // Сброс позиции и масштаба
        window.resetCanvasPosition = function() {
          translateX = 0;
          translateY = 0;
          scale = 1;
          updateCanvasTransform();
        };

        // Функции для управления масштабом
        window.zoomIn = function() {
          if (scale < 3) {
            scale *= 1.2;
            updateCanvasTransform();
          }
        };

        window.zoomOut = function() {
          if (scale > 0.5) {
            scale *= 0.8;
            updateCanvasTransform();
          }
        };

        console.log('Canvas panning и zoom настроены');
      }

      // Слушаем сообщения от родительского окна
      window.addEventListener('message', function(event) {
        console.log('RedBlack.html: Получено сообщение', event.data);
        
        if (event.data && event.data.type === 'LOAD_PACKAGES') {
          window.packagesToLoad = event.data.packages || [];
          console.log(`RedBlack.html: Получено ${window.packagesToLoad.length} посылок`);
          
          // Если дерево уже готово, загружаем сразу
          if (window.treeInitialized && typeof currentAlg !== 'undefined') {
            loadPackagesIntoTree();
          }
        }
      });

      // Функция загрузки посылок в дерево
      function loadPackagesIntoTree() {
        if (!window.packagesToLoad || window.packagesToLoad.length === 0) {
          console.log('RedBlack.html: Нет посылок для загрузки');
          return;
        }

        if (typeof currentAlg === 'undefined' || !currentAlg) {
          console.error('RedBlack.html: currentAlg не определен');
          return;
        }

        console.log(`RedBlack.html: Начинаем загрузку ${window.packagesToLoad.length} посылок`);

        // Очищаем дерево
        try {
          if (typeof currentAlg.clearCallback === 'function') {
            currentAlg.clearCallback();
          }
        } catch (e) {
          console.warn('RedBlack.html: Не удалось очистить дерево:', e);
        }

        // Получаем уникальных отправителей
        const uniqueSenders = [...new Set(window.packagesToLoad.map(pkg => pkg.senderPhone.toString()))];
        console.log(`RedBlack.html: Найдено ${uniqueSenders.length} уникальных отправителей`);

        // Вставляем каждого отправителя
        uniqueSenders.forEach((senderPhone, index) => {
          setTimeout(() => {
            try {
              console.log(`RedBlack.html: Вставляем ключ ${index + 1}/${uniqueSenders.length}: ${senderPhone}`);
              
              const commands = currentAlg.insertElement(senderPhone);
              if (commands && currentAlg.animationManager) {
                currentAlg.animationManager.StartNewAnimation(commands);
                currentAlg.animationManager.skipForward();
                currentAlg.animationManager.clearHistory();
              }
            } catch (error) {
              console.error(`RedBlack.html: Ошибка при вставке ${senderPhone}:`, error);
            }
          }, index * 100); // Небольшая задержка между вставками
        });
      }


      // Перехватываем оригинальный init
      function setupInit() {
        // Ждем пока init станет доступен
        if (typeof window.init === 'function') {
          const originalInit = window.init;
          
          window.init = function() {
            console.log('RedBlack.html: Вызов init()');
            
            try {
              // Вызываем оригинальную инициализацию
              originalInit();
              
              window.treeInitialized = true;
              
              // Загружаем данные, если они уже есть
              setTimeout(() => {
                loadPackagesIntoTree();
              }, 500);
              
            } catch (error) {
              console.error('RedBlack.html: Ошибка инициализации:', error);
            }
          };
          
          console.log('RedBlack.html: init() перехвачен');
        } else {
          // Если init еще не готов, проверяем снова
          setTimeout(setupInit, 100);
        }
      }

      // Запускаем после загрузки DOM
      document.addEventListener('DOMContentLoaded', function() {
        console.log('RedBlack.html: DOM загружен');
        
        // Настраиваем канвас сразу после загрузки DOM
        setTimeout(() => {
          const canvas = document.getElementById('canvas');
          if (canvas) {
            console.log('Настройка высокого DPI и перемещения канваса...');
            setupHighDPICanvas(canvas);
            setupCanvasPanning(canvas);
          }
        }, 100);
        
        setupInit();
      });

      // Функция для ручной загрузки (для отладки)
      function manualLoad() {
        loadPackagesIntoTree();
      }
    </script>
  </head>

  <body onload="init();">
    <div id="container">


      <div id="mainContent">
        <div id="algoControlSection">
          <table id="AlgorithmSpecificControls"></table>
        </div>

        <div id="canvas-container">
          <canvas id="canvas" width="3000" height="2000"></canvas>
        </div>

        <div id="generalAnimationControlSection">
          <table id="GeneralAnimationControls"></table>
        </div>
    </div>
  </body>
</html>